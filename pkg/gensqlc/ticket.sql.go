// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ticket.sql

package gensqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteTicket = `-- name: DeleteTicket :exec
DELETE
FROM tickets
WHERE id = $1
`

type DeleteTicketParams struct {
	ID uuid.UUID `json:"id"`
}

func (q *Queries) DeleteTicket(ctx context.Context, arg DeleteTicketParams) error {
	_, err := q.db.Exec(ctx, deleteTicket, arg.ID)
	return err
}

const getAllByPassenger = `-- name: GetAllByPassenger :many
SELECT id,
       passenger_id,
       order_number,
       departure,
       destination,
       service_provider,
       departure_date,
       arrival_date,
       order_date
FROM tickets
WHERE passenger_id = $1
`

type GetAllByPassengerParams struct {
	PassengerID uuid.UUID `json:"passenger_id"`
}

func (q *Queries) GetAllByPassenger(ctx context.Context, arg GetAllByPassengerParams) ([]*Ticket, error) {
	rows, err := q.db.Query(ctx, getAllByPassenger, arg.PassengerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.PassengerID,
			&i.OrderNumber,
			&i.Departure,
			&i.Destination,
			&i.ServiceProvider,
			&i.DepartureDate,
			&i.ArrivalDate,
			&i.OrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTickets = `-- name: GetAllTickets :many
SELECT id,
       passenger_id,
       order_number,
       departure,
       destination,
       service_provider,
       departure_date,
       arrival_date,
       order_date
FROM tickets
ORDER BY order_date LIMIT $1
OFFSET $2
`

type GetAllTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllTickets(ctx context.Context, arg GetAllTicketsParams) ([]*Ticket, error) {
	rows, err := q.db.Query(ctx, getAllTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.PassengerID,
			&i.OrderNumber,
			&i.Departure,
			&i.Destination,
			&i.ServiceProvider,
			&i.DepartureDate,
			&i.ArrivalDate,
			&i.OrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountTickets = `-- name: GetCountTickets :one
SELECT count(*) AS count
FROM tickets
`

func (q *Queries) GetCountTickets(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountTickets)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOneTicket = `-- name: GetOneTicket :one
SELECT t.id, t.passenger_id, t.order_number, t.departure, t.destination, t.service_provider, t.departure_date, t.arrival_date, t.order_date,
       p.id, p.first_name, p.last_name, p.middle_name,
       d.id, d.passenger_id, d.type, d.number
FROM tickets t
         left JOIN passengers p ON p.id = t.passenger_id
         left JOIN documents d ON d.passenger_id = p.id
WHERE t.id = $1
`

type GetOneTicketParams struct {
	ID uuid.UUID `json:"id"`
}

type GetOneTicketRow struct {
	ID              uuid.UUID `json:"id"`
	PassengerID     uuid.UUID `json:"passenger_id"`
	OrderNumber     string    `json:"order_number"`
	Departure       string    `json:"departure"`
	Destination     string    `json:"destination"`
	ServiceProvider string    `json:"service_provider"`
	DepartureDate   time.Time `json:"departure_date"`
	ArrivalDate     time.Time `json:"arrival_date"`
	OrderDate       time.Time `json:"order_date"`
	Passenger       Passenger `json:"passenger"`
	Document        Document  `json:"document"`
}

func (q *Queries) GetOneTicket(ctx context.Context, arg GetOneTicketParams) (*GetOneTicketRow, error) {
	row := q.db.QueryRow(ctx, getOneTicket, arg.ID)
	var i GetOneTicketRow
	err := row.Scan(
		&i.ID,
		&i.PassengerID,
		&i.OrderNumber,
		&i.Departure,
		&i.Destination,
		&i.ServiceProvider,
		&i.DepartureDate,
		&i.ArrivalDate,
		&i.OrderDate,
		&i.Passenger.ID,
		&i.Passenger.FirstName,
		&i.Passenger.LastName,
		&i.Passenger.MiddleName,
		&i.Document.ID,
		&i.Document.PassengerID,
		&i.Document.Type,
		&i.Document.Number,
	)
	return &i, err
}

const getPassengerReport = `-- name: GetPassengerReport :many
SELECT t.order_date,
       t.departure_date,
       t.order_number,
       t.departure,
       t.destination,
       CASE
           WHEN t.departure_date <= NOW() THEN true
           ELSE false
           END AS service_provided
FROM tickets t
         JOIN passengers p ON t.passenger_id = p.id
WHERE p.id = $1
  AND (
    (t.order_date < $2 AND t.departure_date BETWEEN $2 AND $3)
        OR (t.order_date BETWEEN $2 AND $3)
    )
ORDER BY t.order_date
`

type GetPassengerReportParams struct {
	ID            uuid.UUID `json:"id"`
	OrderDate     time.Time `json:"order_date"`
	DepartureDate time.Time `json:"departure_date"`
}

type GetPassengerReportRow struct {
	OrderDate       time.Time `json:"order_date"`
	DepartureDate   time.Time `json:"departure_date"`
	OrderNumber     string    `json:"order_number"`
	Departure       string    `json:"departure"`
	Destination     string    `json:"destination"`
	ServiceProvided bool      `json:"service_provided"`
}

func (q *Queries) GetPassengerReport(ctx context.Context, arg GetPassengerReportParams) ([]*GetPassengerReportRow, error) {
	rows, err := q.db.Query(ctx, getPassengerReport, arg.ID, arg.OrderDate, arg.DepartureDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPassengerReportRow
	for rows.Next() {
		var i GetPassengerReportRow
		if err := rows.Scan(
			&i.OrderDate,
			&i.DepartureDate,
			&i.OrderNumber,
			&i.Departure,
			&i.Destination,
			&i.ServiceProvided,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets
SET order_number     = COALESCE($1, order_number),
    departure        = COALESCE($2, departure),
    destination      = COALESCE($3, destination),
    service_provider = COALESCE($4, service_provider),
    departure_date   = COALESCE($5, departure_date),
    arrival_date     = COALESCE($6, arrival_date),
    order_date       = COALESCE($7, order_date)
WHERE id = $8 RETURNING id, passenger_id, order_number, departure, destination, service_provider, departure_date, arrival_date, order_date
`

type UpdateTicketParams struct {
	OrderNumber     string    `json:"order_number"`
	Departure       string    `json:"departure"`
	Destination     string    `json:"destination"`
	ServiceProvider string    `json:"service_provider"`
	DepartureDate   time.Time `json:"departure_date"`
	ArrivalDate     time.Time `json:"arrival_date"`
	OrderDate       time.Time `json:"order_date"`
	ID              uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (*Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicket,
		arg.OrderNumber,
		arg.Departure,
		arg.Destination,
		arg.ServiceProvider,
		arg.DepartureDate,
		arg.ArrivalDate,
		arg.OrderDate,
		arg.ID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.PassengerID,
		&i.OrderNumber,
		&i.Departure,
		&i.Destination,
		&i.ServiceProvider,
		&i.DepartureDate,
		&i.ArrivalDate,
		&i.OrderDate,
	)
	return &i, err
}
